# Algorithms
# Sorting algorithms
* _Bubble Sort_
* _Merge Sort_
* _Selection sort_
* _Quick sort_

**Bubble Sort**

It is comparison sorting algorithms that starts at the beginning and compares each pair of adjacent items and swaps them if they are in the wrong order. O(n^2).

Links:

https://en.wikipedia.org/wiki/Bubble_sort

http://interactivepython.org/courselib/static/pythonds/SortSearch/TheBubbleSort.html

**Merge Sort**

It is a divide and conquer algorithm. It divides the array into equal halves and then combines them in a sorted manner. O(n log n)

Links:

https://en.wikipedia.org/wiki/Merge_sort

https://www.tutorialspoint.com/data_structures_algorithms/merge_sort_algorithm.htm

**Selection Sort**

The algorithm scans the array for the smallest item and moves it to the front. Then, repeat for rest items. O(n^2)

Links:

https://en.wikipedia.org/wiki/Selection_sort

https://www.tutorialspoint.com/data_structures_algorithms/selection_sort_algorithm.htm

**Quick Sort**

It is comparison divide and conquer sorting algorithm. The algorithm divides a large array into two sub-arrays. Quicksort can then recursively sort the sub-arrays. O(n log n) expected, O(n^2) worst case.

Links:

https://en.wikipedia.org/wiki/Quicksort#Algorithm

https://www.tutorialspoint.com/data_structures_algorithms/quick_sort_algorithm.htm

# Searching algorithms

* _Binary search_ 

**Binary search**

Search algorithm that finds the position of a target value within a sorted array. It compares the target value to the middle item of the array. If a match occurs, then the index of item is returned. If the middle item is greater than the item, then the item is searched in the sub-array to the left of the middle item. Otherwise, the item is searched for in the sub-array to the right of the middle item. This process continues on the sub-array as well until the size of the subarray reduces to zero. ÎŸ(log n). 

Links:

https://en.wikipedia.org/wiki/Binary_search_algorithm

.
